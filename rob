#define ticks_per_rev 200
#define wheel_rayon 30
#define center_distance 100
#define kd 0.01
#define kp 1
#define ki 0.5
#define pi 3.14159265

#define encoderRa 1
#define encoderRb 2
#define encoderLa 7
#define encoderLb 8

#define MR1 3
#define MR2 5
#define ML1 6
#define ML2 9

long counterR=0;
long counterL=0;
float wheel_perimeter= 2*pi*wheel_rayon;
float tickmm=wheel_perimeter/ticks_per_rev;
float setpoint = 200;
float error=0;
float prevError=0;
float Integral=0;
float Derivate=0;
float output=0;
unsigned long now=0;
unsigned long lastTime=0;
unsigned long dt=0;
int a=0;
int b=0;
  
void setup()
{
  attachInterrupt(digitalPinToInterrupt(encoderLa),ReadEncoderLa,CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderRb),ReadEncoderLb,CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderRa),ReadEncoderRa,CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderRb),ReadEncoderRb,CHANGE);   
}

void loop()
{
  
  
  
}

void ReadEncoderLa(){
  int a= digitalRead(encoderLa);
  int b= digitalRead(encoderLb);
  if(a^b){
    counterL ++;
  }
  else{
    counterL--;
  }
}

void ReadEncoderLb(){
  int a= digitalRead(encoderLa);
  int b= digitalRead(encoderLb);
  if(!(a^b)){
    counterL ++;
  }
  else{
    counterL--;
  }
}

void ReadEncoderRa(){
  int a= digitalRead(encoderRa);
  int b= digitalRead(encoderRb);
  if(a^b){
    counterR++;
  }
  else{
    counterR--;
  }
}

void ReadEncoderRb(){
  int a= digitalRead(encoderRa);
  int b= digitalRead(encoderRb);
  if(!(a^b)){
    counterR ++;
  }
  else{
    counterR--;
  }
}


float tickstomm(float ticks){
  return ticks* tickmm;
  }
  
float mmtoticks(float mm){
  return mm/tickmm;
  }



void moveRobot(float setpoint){
  while (((tickstomm(counterR)+tickstomm(counterL))/2)  < setpoint ){
      moveMR(setpoint);
      moveML(setpoint);  
  }


}
void moveMR(float setpoint){
    now = millis();
    dt= now - lastTime;
    error = setpoint - tickstomm(counterR);
    Integral += error * dt;
    Derivate= (error-prevError) /dt;
    output = kp * error + ki *Integral+ kd * Derivate;
    if (output>255){output=255;}
    if (output<-255){output=-255;}

    if (output>0)
    {
      analogWrite(MR1,abs(output)); 
      analogWrite(MR2,0); 
    }
    else
    {
      analogWrite(MR2,abs(output)); 
      analogWrite(MR1,0); 
    }


    prevError =error;
    lastTime =now;
 }
 
 
 
 void moveML(float setpoint){
    now = millis();
    dt= now - lastTime;
    error = setpoint - tickstomm(counterL);
    Integral += error * dt;
    Derivate= (error-prevError) /dt;
    output = kp * error + ki *Integral+ kd * Derivate;
    if (output>255){output=255;}
    if (output<-255){output=-255;}

    if (output>0)
    {
      analogWrite(ML1,abs(output)); 
      analogWrite(ML2,0); 
    }
    else
    {
      analogWrite(ML2,abs(output)); 
      analogWrite(ML1,0); 
    }
    prevError =error;
    lastTime =now;
 }
 
void  tournerDroit(){
    float theta = 0;
    float deltaTheta=0;
    float prevR=tickstomm(counterR);
    float prevL=tickstomm(counterL);
    float distance=(pi/2)*(center_distance);
    while ((abs(theta))<(pi/2)){
        moveML(distance);
        moveMR(-distance);
        deltaTheta=((counterR-prevR)-(counterL-prevL))/(2*center_distance);
        prevL=counterL;
        prevR=counterR; 
        theta+=deltaTheta; 
    }
}
void  tournerGauche(){
    float theta = 0;
    float deltaTheta=0;
    float prevR=tickstomm(counterR);
    float prevL=tickstomm(counterL);
    float distance=(pi/2)*(center_distance);
    while ((abs(theta))<(pi/2)){
        moveML(-distance);
        moveMR(distance);
        deltaTheta=((counterR-prevR)-(counterL-prevL))/(2*center_distance);
        prevL=counterL;
        prevR=counterR; 
        theta+=deltaTheta; 
    }   
}
