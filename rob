#define ticks_per_rev 200
#define wheel_rayon 30
#define center_distance
#define kd 0.01
#define kp 1
#define ki 0.5
#define pi 3.14159
#define sampleTime 10

#define encoderRa 1
#define encoderRb 2
#define encoderLa 7
#define encoderLb 8

#define MR1 3
#define MR2 5
#define ML1 6
#define ML2 9

long counterR=0;
long counterL=0;
float wheel_perimeter= 2*pi*wheel_rayon;
float setpoint = 200;
float error=0;
float prevError=0;
float Integral=0;
float Derivate=0;
int output=0;
unsigned long now=0;
unsigned long lastTime=0;
unsigned long dt=0;
int a=0;
int b=0;
  
void setup()
{
  attachInterrupt(digitalPinToInterrupt(encoderLa),ReadEncoderLa,CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderRb),ReadEncoderLb,CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderRa),ReadEncoderRa,CHANGE);
  attachInterrupt(digitalPinToInterrupt(encoderRb),ReadEncoderRb,CHANGE);   
}

void loop()
{
  
  
  
}
void ReadEncoderLa(){
  int a= digitalRead(encoderLa);
  int b= digitalRead(encoderLb);
  if(a^b){
    counterL ++;
  }
  else{
    counterL--;
  }
}
void ReadEncoderLb(){
  int a= digitalRead(encoderLa);
  int b= digitalRead(encoderLb);
  if(!(a^b)){
    counterL ++;
  }
  else{
    counterL--;
  }
}

void ReadEncoderRa(){
  int a= digitalRead(encoderRa);
  int b= digitalRead(encoderRb);
  if(a^b){
    counterR++;
  }
  else{
    counterR--;
  }
}

void ReadEncoderRb(){
  int a= digitalRead(encoderRa);
  int b= digitalRead(encoderRb);
  if(!(a^b)){
    counterR ++;
  }
  else{
    counterR--;
  }
}

float tickstomm(float ticks){
  float tickmm=wheel_perimeter/ticks_per_rev;
  return ticks* tickmm;
  }
// Define constants for the PID controller
const float kp = 1.0; // Proportional constant
const float ki = 0.1; // Integral constant
const float kd = 0.05; // Derivative constant









void moveMR(){
   now = millis();
   dt= now - last_time;
  if (dt>= sampleTime) {
    float error = setpoint - counterR;

   Integral += error * dt;

   Derivative= (error-prevError) /dt;

    output = kp * error + ki *Integral+ kd * Derivate;

    if (output > 0.0) {
      // Set the motor direction to forward
      digitalWrite(motor_pin1, HIGH);
      digitalWrite(motor_pin2, LOW);
    } else {
      // Set the motor direction to backward
      digitalWrite(motor_pin1, LOW);
      digitalWrite(motor_pin2, HIGH);
      // Invert the output signal to make it positive for the motor driver
      output = -output;
    }

    // Set the motor speed based on the output signal
    analogWrite(motor_pin1, output);

    // Remember the current speed measurement and the last loop time
    last_input = input;
    last_time = now;
  }
 }

